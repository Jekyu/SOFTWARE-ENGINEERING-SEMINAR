\section{Dockerfiles and Containerization}

This project includes three independent components: a Java authentication service, a Python core service, and a web frontend built with HTML5. To containerize the entire application, each service is packaged into its own Docker image and orchestrated through a central \texttt{docker-compose.yml} file.

\subsection{Folder Structure}

The application is located in:
\begin{verbatim}
Docs/Workshops/Workshop-4/app/
\end{verbatim}

The relevant structure of the project is:

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.25\linewidth]{Dockerfiles/dir.png}
\end{figure}

Each service is isolated inside its own directory, which allows it to be built and executed independently while maintaining clear separation of concerns.

\subsection{Dockerfile for the Java Authentication Service}

The Java service is built with Maven and produces a JAR file inside the \texttt{target/} directory. A multi-stage Dockerfile is used to compile the application and run it using a lightweight JRE image:

\begin{verbatim}
FROM maven:3.9.6-eclipse-temurin-17 AS build
WORKDIR /app
COPY . .
RUN mvn -q -DskipTests package

FROM eclipse-temurin:17-jre
WORKDIR /app
COPY --from=build /app/target/*.jar app.jar
EXPOSE 8080
CMD ["java", "-jar", "app.jar"]
\end{verbatim}

\subsection{Dockerfile for the Python Core Service}

The Python service exposes an API and includes a standard \texttt{requirements.txt}. Its Dockerfile installs dependencies and runs the main script:

\begin{verbatim}
FROM python:3.12-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000
CMD ["python", "main.py"]
\end{verbatim}

\subsection{Dockerfile for the Web Frontend}

If the frontend consists of static HTML, CSS, and JavaScript files, it can be served using NGINX:

\begin{verbatim}
FROM nginx:latest
COPY . /usr/share/nginx/html
EXPOSE 80
\end{verbatim}

This creates a lightweight web server that serves the static site directly.

\subsection{Docker Compose Orchestration}

All services are orchestrated using \texttt{docker-compose.yml}, which builds and runs each container and connects them through a shared network:

\begin{verbatim}
version: "3.9"

services:

  auth-service:
    build: ./auth-service
    ports:
      - "8080:8080"
    networks:
      - appnet

  core-service:
    build: ./core-service
    ports:
      - "8000:8000"
    networks:
      - appnet
    depends_on:
      - auth-service

  web:
    build: ./web
    ports:
      - "3000:80"
    networks:
      - appnet
    depends_on:
      - core-service
      - auth-service

networks:
  appnet:
    driver: bridge
\end{verbatim}

\subsection{Running the Application}

To build and run the entire application, execute:

\begin{verbatim}
docker compose up --build
\end{verbatim}

This command builds each image, creates the network, and launches all services.
The system becomes accessible on the following endpoints:

\begin{itemize}
    \item Web frontend: \texttt{http://localhost:3000}
    \item Python core service: \texttt{http://localhost:8000}
    \item Java authentication service: \texttt{http://localhost:8080}
\end{itemize}

To stop the system:

\begin{verbatim}
docker compose down
\end{verbatim}

This workflow provides a clean and reproducible environment for running the entire multi-service application.
